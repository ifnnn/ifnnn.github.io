<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Ying Cai <i@caiying.me>">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>排序 - Ying 的学习笔记</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u6392\u5e8f";
    var mkdocs_page_input_path = "dsa-sort.md";
    var mkdocs_page_url = "/dsa-sort/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Ying 的学习笔记</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">首页</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../about/">关于</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">分享</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../ppt-git-tutorial/">Git 入门手册</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">数据结构与算法</span>
    <ul class="subnav">
                <li class=" current">
                    
    <a class="current" href="./">排序</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#_1">排序</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#_2">比较排序</a></li>
        
            <li><a class="toctree-l4" href="#_9">堆排序</a></li>
        
            <li><a class="toctree-l4" href="#_10">基数排序</a></li>
        
            <li><a class="toctree-l4" href="#_11">计数排序</a></li>
        
            <li><a class="toctree-l4" href="#_12">桶排序</a></li>
        
            <li><a class="toctree-l4" href="#_13">附录</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../dsa-indexing/">索引</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">OPS</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../ops-rabbitmq/">rabbitmq</a>
                </li>
                <li class="">
                    
    <a class="" href="../ops-docker/">docker</a>
                </li>
                <li class="">
                    
    <a class="" href="../ops-docker-alpine/">镜像构建</a>
                </li>
                <li class="">
                    
    <a class="" href="../ops-zk/">运维 - zookeeper</a>
                </li>
                <li class="">
                    
    <a class="" href="../ops-jenkins/">运维 - jenkins</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">最佳实践</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../env-dotfiles/">dotfile</a>
                </li>
                <li class="">
                    
    <a class="" href="../env-linux/">Linux</a>
                </li>
                <li class="">
                    
    <a class="" href="../env-python/">Python</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Ying 的学习笔记</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>数据结构与算法 &raquo;</li>
        
      
    
    <li>排序</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="_1">排序<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h2 id="_2">比较排序<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">排序可视化</a></li>
</ul>
<h3 id="_3">冒泡排序<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<pre><code class="java">void bubbleSort(int arr[]) { 
    int n = arr.length; 
    for (int i = 0; i &lt; n-1; i++) 
        for (int j = 0; j &lt; n-i-1; j++) 
            if (arr[j] &gt; arr[j+1]) 
            { 
                // swap arr[j+1] and arr[i] 
                int temp = arr[j]; 
                arr[j] = arr[j+1]; 
                arr[j+1] = temp; 
            } 
}


// An optimized version of Bubble Sort 
void bubbleSort(int arr[], int n) { 
    int i, j, temp; 
    boolean swapped; 
    for (i = 0; i &lt; n - 1; i++)  
    { 
        swapped = false; 
        for (j = 0; j &lt; n - i - 1; j++)  
        { 
            if (arr[j] &gt; arr[j + 1])  
            { 
                // swap arr[j] and arr[j+1] 
                temp = arr[j]; 
                arr[j] = arr[j + 1]; 
                arr[j + 1] = temp; 
                swapped = true; 
            } 
        } 

        // IF no two elements were  
        // swapped by inner loop, then break 
        if (swapped == false) 
            break; 
    } 
} 
</code></pre>

<h3 id="_4">选择排序<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<pre><code class="java">void selectionSort(int arr[]) {
    int n = arr.length; 

    // One by one move boundary of unsorted subarray 
    for (int i = 0; i &lt; n-1; i++) 
    { 
        // Find the minimum element in unsorted array 
        int min_idx = i; 
        for (int j = i+1; j &lt; n; j++) 
            if (arr[j] &lt; arr[min_idx]) 
                min_idx = j; 

        // Swap the found minimum element with the first 
        // element 
        int temp = arr[min_idx]; 
        arr[min_idx] = arr[i]; 
        arr[i] = temp; 
    } 
}
</code></pre>

<h3 id="_5">插入排序<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<pre><code class="java">void insertionSort(int arr[]) { 
    int n = arr.length; 
    for (int i = 1; i &lt; n; ++i) { 
        int key = arr[i]; 
        int j = i - 1; 

        /* Move elements of arr[0..i-1], that are 
           greater than key, to one position ahead 
           of their current position */
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { 
            arr[j + 1] = arr[j]; 
            j = j - 1; 
        } 
        arr[j + 1] = key; 
    } 
}
</code></pre>

<h3 id="_6">归并排序<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<pre><code class="java">// Merges two subarrays of arr[]. 
// First subarray is arr[l..m] 
// Second subarray is arr[m+1..r] 
void merge(int arr[], int l, int m, int r) 
{ 
    // Find sizes of two subarrays to be merged 
    int n1 = m - l + 1; 
    int n2 = r - m; 

    /* Create temp arrays */
    int L[] = new int[n1]; 
    int R[] = new int[n2]; 

    /*Copy data to temp arrays*/
    for (int i = 0; i &lt; n1; ++i) 
        L[i] = arr[l + i]; 
    for (int j = 0; j &lt; n2; ++j) 
        R[j] = arr[m + 1 + j]; 

    /* Merge the temp arrays */

    // Initial indexes of first and second subarrays 
    int i = 0, j = 0; 

    // Initial index of merged subarry array 
    int k = l; 
    while (i &lt; n1 &amp;&amp; j &lt; n2) { 
        if (L[i] &lt;= R[j]) { 
            arr[k] = L[i]; 
            i++; 
        } 
        else { 
            arr[k] = R[j]; 
            j++; 
        } 
        k++; 
    } 

    /* Copy remaining elements of L[] if any */
    while (i &lt; n1) { 
        arr[k] = L[i]; 
        i++; 
        k++; 
    } 

    /* Copy remaining elements of R[] if any */
    while (j &lt; n2) { 
        arr[k] = R[j]; 
        j++; 
        k++; 
    } 
} 

// Main function that sorts arr[l..r] using merge() 
void sort(int arr[], int l, int r) 
{ 
    if (l &lt; r) { 
        // Find the middle point 
        int m = (l + r) / 2; 

        // Sort first and second halves 
        sort(arr, l, m); 
        sort(arr, m + 1, r); 

        // Merge the sorted halves 
        merge(arr, l, m, r); 
    } 
}
</code></pre>

<h3 id="_7">希尔排序<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<pre><code class="java">/* function to sort arr using shellSort */
int sort(int arr[]) { 
    int n = arr.length; 

    // Start with a big gap, then reduce the gap 
    for (int gap = n/2; gap &gt; 0; gap /= 2) 
    { 
        // Do a gapped insertion sort for this gap size. 
        // The first gap elements a[0..gap-1] are already 
        // in gapped order keep adding one more element 
        // until the entire array is gap sorted 
        for (int i = gap; i &lt; n; i += 1) 
        { 
            // add a[i] to the elements that have been gap 
            // sorted save a[i] in temp and make a hole at 
            // position i 
            int temp = arr[i]; 

            // shift earlier gap-sorted elements up until 
            // the correct location for a[i] is found 
            int j; 
            for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) 
                arr[j] = arr[j - gap]; 

            // put temp (the original a[i]) in its correct 
            // location 
            arr[j] = temp; 
        } 
    } 
    return 0; 
}
</code></pre>

<h3 id="_8">快速排序<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<pre><code class="java">/* This function takes last element as pivot, 
   places the pivot element at its correct 
   position in sorted array, and places all 
   smaller (smaller than pivot) to left of 
   pivot and all greater elements to right 
   of pivot */
int partition(int arr[], int low, int high) { 
    int pivot = arr[high];  
    int i = (low-1); // index of smaller element 
    for (int j=low; j&lt;high; j++) 
    { 
        // If current element is smaller than the pivot 
        if (arr[j] &lt; pivot) 
        { 
            i++; 

            // swap arr[i] and arr[j] 
            int temp = arr[i]; 
            arr[i] = arr[j]; 
            arr[j] = temp; 
        } 
    } 

    // swap arr[i+1] and arr[high] (or pivot) 
    int temp = arr[i+1]; 
    arr[i+1] = arr[high]; 
    arr[high] = temp; 

    return i+1; 
} 


/* The main function that implements QuickSort() 
  arr[] --&gt; Array to be sorted, 
  low  --&gt; Starting index, 
  high  --&gt; Ending index */
void sort(int arr[], int low, int high) { 
    if (low &lt; high) 
    { 
        /* pi is partitioning index, arr[pi] is  
          now at right place */
        int pi = partition(arr, low, high); 

        // Recursively sort elements before 
        // partition and after partition 
        sort(arr, low, pi-1); 
        sort(arr, pi+1, high); 
    } 
} 
</code></pre>

<h2 id="_9">堆排序<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h2>
<pre><code class="java">void sort(int arr[]) { 
    int n = arr.length; 

    // Build heap (rearrange array) 
    for (int i = n / 2 - 1; i &gt;= 0; i--) 
        heapify(arr, n, i); 

    // One by one extract an element from heap 
    for (int i=n-1; i&gt;0; i--) 
    { 
        // Move current root to end 
        int temp = arr[0]; 
        arr[0] = arr[i]; 
        arr[i] = temp; 

        // call max heapify on the reduced heap 
        heapify(arr, i, 0); 
    } 
} 

// To heapify a subtree rooted with node i which is 
// an index in arr[]. n is size of heap 
void heapify(int arr[], int n, int i) { 
    int largest = i; // Initialize largest as root 
    int l = 2*i + 1; // left = 2*i + 1 
    int r = 2*i + 2; // right = 2*i + 2 

    // If left child is larger than root 
    if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) 
        largest = l; 

    // If right child is larger than largest so far 
    if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) 
        largest = r; 

    // If largest is not root 
    if (largest != i) 
    { 
        int swap = arr[i]; 
        arr[i] = arr[largest]; 
        arr[largest] = swap; 

        // Recursively heapify the affected sub-tree 
        heapify(arr, n, largest); 
    } 
} 
</code></pre>

<h2 id="_10">基数排序<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h2>
<pre><code class="java">// A utility function to get maximum value in arr[] 
int getMax(int arr[], int n) { 
    int mx = arr[0]; 
    for (int i = 1; i &lt; n; i++) 
        if (arr[i] &gt; mx) 
            mx = arr[i]; 
    return mx; 
} 

// A function to do counting sort of arr[] according to 
// the digit represented by exp. 
void countSort(int arr[], int n, int exp) { 
    int output[] = new int[n]; // output array 
    int i; 
    int count[] = new int[10]; 
    Arrays.fill(count,0); 

    // Store count of occurrences in count[] 
    for (i = 0; i &lt; n; i++) 
        count[ (arr[i]/exp)%10 ]++; 

    // Change count[i] so that count[i] now contains 
    // actual position of this digit in output[] 
    for (i = 1; i &lt; 10; i++) 
        count[i] += count[i - 1]; 

    // Build the output array 
    for (i = n - 1; i &gt;= 0; i--) 
    { 
        output[count[ (arr[i]/exp)%10 ] - 1] = arr[i]; 
        count[ (arr[i]/exp)%10 ]--; 
    } 

    // Copy the output array to arr[], so that arr[] now 
    // contains sorted numbers according to curent digit 
    for (i = 0; i &lt; n; i++) 
        arr[i] = output[i]; 
} 

// The main function to that sorts arr[] of size n using 
// Radix Sort 
void radixsort(int arr[], int n) { 
    // Find the maximum number to know number of digits 
    int m = getMax(arr, n); 

    // Do counting sort for every digit. Note that instead 
    // of passing digit number, exp is passed. exp is 10^i 
    // where i is current digit number 
    for (int exp = 1; m/exp &gt; 0; exp *= 10) 
        countSort(arr, n, exp); 
} 
</code></pre>

<h2 id="_11">计数排序<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h2>
<pre><code class="java">void sort(char arr[]) { 
    int n = arr.length; 

    // The output character array that will have sorted arr 
    char output[] = new char[n]; 

    // Create a count array to store count of inidividul 
    // characters and initialize count array as 0 
    int count[] = new int[256]; 
    for (int i=0; i&lt;256; ++i) 
        count[i] = 0; 

    // store count of each character 
    for (int i=0; i&lt;n; ++i) 
        ++count[arr[i]]; 

    // Change count[i] so that count[i] now contains actual 
    // position of this character in output array 
    for (int i=1; i&lt;=255; ++i) 
        count[i] += count[i-1]; 

    // Build the output character array 
    // To make it stable we are operating in reverse order. 
    for (int i = n-1; i&gt;=0; i--) 
    { 
        output[count[arr[i]]-1] = arr[i]; 
        --count[arr[i]]; 
    } 

    // Copy the output array to arr, so that arr now 
    // contains sorted characters 
    for (int i = 0; i&lt;n; ++i) 
        arr[i] = output[i]; 
}
</code></pre>

<h2 id="_12">桶排序<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h2>
<pre><code class="java">void bucketSort(int[] intArr, int noOfBuckets){
    // Create bucket array
    List&lt;Integer&gt;[] buckets = new List[noOfBuckets];
    // Associate a list with each index 
    // in the bucket array         
    for(int i = 0; i &lt; noOfBuckets; i++){
        buckets[i] = new LinkedList&lt;&gt;();
    }
    // Assign numbers from array to the proper bucket
    // by using hashing function
    for(int num : intArr){
        //System.out.println(&quot;hash- &quot; + hash(num));
        buckets[hash(num)].add(num);
    }
    // sort buckets
    for(List&lt;Integer&gt; bucket : buckets){
        Collections.sort(bucket);
    }
    int i = 0;
    // Merge buckets to get sorted array
    for(List&lt;Integer&gt; bucket : buckets){
        for(int num : bucket){
            intArr[i++] = num;
        }
    }
}

// A very simple hash function
int hash(int num){
    return num/10;
}
</code></pre>

<h2 id="_13">附录<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></li>
<li>常用搜索算法时间复杂度</li>
</ul>
<p><img alt="" src="https://img.ifnnn.cn/13f6ca2ad3a5f900a83bdbc86f32edbf.png?imageView2/2/w/640" /></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../dsa-indexing/" class="btn btn-neutral float-right" title="索引">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../ppt-git-tutorial/" class="btn btn-neutral" title="Git 入门手册"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>© Copyright 2020, 京ICP备18023798号-1</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../ppt-git-tutorial/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../dsa-indexing/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
